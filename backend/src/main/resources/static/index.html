<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MailVault - Historical Inbox</title>
  <style>
    :root {
      --bg: #f7f4ef;
      --bg-2: #ede5d8;
      --panel: #fffdfa;
      --line: #d9cfbf;
      --ink: #1d1a15;
      --muted: #5e5649;
      --accent: #176d5b;
      --accent-strong: #0e4f41;
      --danger: #7a2f2f;
      --shadow: 0 16px 30px rgba(37, 31, 20, 0.08);
      --radius-lg: 18px;
      --radius-md: 12px;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      color: var(--ink);
      font-family: "Iowan Old Style", "Palatino Linotype", "Book Antiqua", Palatino, serif;
      background:
        radial-gradient(circle at 10% 0%, rgba(23, 109, 91, 0.13), transparent 40%),
        radial-gradient(circle at 100% 15%, rgba(182, 132, 58, 0.12), transparent 42%),
        linear-gradient(140deg, var(--bg), var(--bg-2));
      min-height: 100vh;
    }

    .wrap {
      width: min(1080px, 92vw);
      margin: 28px auto 42px;
    }

    .hero {
      background: linear-gradient(145deg, #1e5b4e, #143d34);
      color: #f8f5ef;
      border-radius: var(--radius-lg);
      padding: 22px 24px;
      box-shadow: var(--shadow);
      position: relative;
      overflow: hidden;
    }

    .hero::after {
      content: "";
      position: absolute;
      width: 260px;
      height: 260px;
      border-radius: 999px;
      background: radial-gradient(circle, rgba(244, 203, 142, 0.28), rgba(244, 203, 142, 0));
      right: -80px;
      top: -110px;
      pointer-events: none;
    }

    h1 {
      margin: 0 0 6px;
      letter-spacing: 0.4px;
      font-size: clamp(1.7rem, 2.6vw, 2.2rem);
    }

    .hero p {
      margin: 0;
      color: rgba(248, 245, 239, 0.9);
      font-size: 1.02rem;
    }

    .panel {
      margin-top: 18px;
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .stats-panel {
      margin-top: 12px;
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow);
      padding: 14px 16px;
    }

    .stats-title {
      margin: 0 0 10px;
      font-size: 1.02rem;
      color: #2a241c;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 8px;
    }

    .stats-card {
      border: 1px solid #d8cab5;
      border-radius: 10px;
      padding: 10px;
      background: #fffcf6;
    }

    .stats-label {
      font-size: .78rem;
      color: #6b5f4b;
      margin-bottom: 4px;
    }

    .stats-value {
      font-size: 1.02rem;
      font-weight: 700;
      color: #2b2419;
    }

    .search {
      display: grid;
      gap: 12px;
      padding: 16px;
      border-bottom: 1px solid var(--line);
      background: linear-gradient(180deg, #fffcf6, #fbf6eb);
    }

    .search-top {
      display: grid;
      grid-template-columns: 1fr auto auto auto;
      gap: 10px;
      align-items: center;
    }

    .language-select {
      min-width: 175px;
    }

    .search input,
    .search select {
      width: 100%;
      border-radius: var(--radius-md);
      border: 1px solid #ccbda8;
      padding: 11px 12px;
      font: inherit;
      color: var(--ink);
      background: #fff;
    }

    .search input:focus,
    .search select:focus {
      outline: 2px solid rgba(23, 109, 91, 0.2);
      border-color: var(--accent);
    }

    .filters-grid {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 10px;
      align-items: end;
    }

    .filter-field {
      display: grid;
      gap: 4px;
    }

    .filter-field label {
      font-size: .82rem;
      color: var(--muted);
      font-weight: 700;
    }

    .filter-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .chips {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      min-height: 28px;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: #efe4d0;
      border: 1px solid #d7c5a8;
      border-radius: 999px;
      padding: 5px 10px;
      font-size: .82rem;
      color: #5f4f36;
    }

    .chip button {
      border: none;
      background: transparent;
      color: #5f4f36;
      padding: 0;
      line-height: 1;
      font-weight: 700;
      cursor: pointer;
    }

    button, .btn {
      border: 1px solid transparent;
      border-radius: var(--radius-md);
      padding: 10px 14px;
      font: inherit;
      cursor: pointer;
      text-decoration: none;
      transition: transform .15s ease, box-shadow .15s ease, background-color .15s ease;
    }

    .btn-primary {
      background: var(--accent);
      color: #fff;
      box-shadow: 0 8px 20px rgba(23, 109, 91, 0.22);
    }

    .btn-primary:hover { background: var(--accent-strong); transform: translateY(-1px); }

    .btn-ghost {
      background: #fff;
      color: var(--ink);
      border-color: #c8bca9;
    }

    .btn-ghost:hover { background: #f4eee2; }

    .meta {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      align-items: center;
      padding: 12px 16px;
      background: #faf6ee;
      border-bottom: 1px solid var(--line);
      color: var(--muted);
      font-size: .96rem;
    }

    .ops {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      align-items: center;
      padding: 12px 16px;
      border-bottom: 1px solid var(--line);
      background: #fff9ee;
    }

    .ops-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .ops-status {
      color: var(--muted);
      font-size: .92rem;
      min-height: 20px;
      border-radius: 8px;
      padding: 4px 8px;
      border: 1px solid transparent;
    }

    .ops-status.ok {
      color: #1f613f;
      background: #e9f6ef;
      border-color: #b7ddc6;
    }

    .ops-status.error {
      color: #772828;
      background: #fdeeee;
      border-color: #edc6c6;
    }

    .ops-status.info {
      color: #1e4c75;
      background: #ebf3fb;
      border-color: #b8d2ea;
    }

    .kbd {
      font-family: "Consolas", "Liberation Mono", monospace;
      background: #f1e8d8;
      border: 1px solid #d5c7ad;
      border-radius: 8px;
      padding: 1px 6px;
      color: #6d5a39;
      font-size: .78rem;
    }

    .list {
      list-style: none;
      margin: 0;
      padding: 0;
    }

    .item {
      border-bottom: 1px solid var(--line);
      padding: 14px 16px;
      transition: background-color .12s ease;
    }

    .item:last-child { border-bottom: none; }
    .item:hover { background: #fff6e8; }

    .item a {
      color: #133f74;
      font-weight: 600;
      text-decoration: none;
    }

    .item a:hover { text-decoration: underline; }

    .item-meta {
      color: var(--muted);
      margin-bottom: 5px;
      font-size: .93rem;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .dot::before {
      content: "•";
      margin-right: 8px;
      color: #978162;
    }

    .item-subject {
      display: inline-block;
      margin-bottom: 4px;
    }

    .item-head {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 4px;
    }

    .item-badges {
      display: inline-flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .mini-badge {
      font-size: .74rem;
      line-height: 1;
      border-radius: 999px;
      border: 1px solid #d8cab5;
      padding: 4px 8px;
      background: #f7efe1;
      color: #5f4f36;
      white-space: nowrap;
    }

    .mini-badge.warn {
      border-color: #d9b48e;
      background: #fff0dd;
      color: #7a4d17;
    }

    .mini-badge.danger {
      border-color: #d39b9b;
      background: #fff0f0;
      color: #8a2f2f;
    }

    .mini-badge.muted {
      border-color: #b7b0a3;
      background: #f4f2ec;
      color: #6a6254;
    }

    .inline-action {
      border: 1px solid #ccbda8;
      background: #fff;
      color: #4a4031;
      border-radius: 999px;
      padding: 4px 8px;
      font-size: .74rem;
      line-height: 1.2;
      cursor: pointer;
    }

    .inline-action:hover {
      background: #f4eee2;
    }

    .item-snippet {
      color: #6a604f;
      font-size: .9rem;
      line-height: 1.3;
    }

    mark {
      background: #fff1be;
      color: #3d2d0c;
      padding: 0 2px;
      border-radius: 3px;
    }

    .empty, .error, .loading {
      padding: 22px 16px;
      color: var(--muted);
    }

    .error { color: var(--danger); }

    .pager {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      padding: 12px 16px 16px;
      background: #fffcf6;
      border-top: 1px solid var(--line);
    }

    .pager-actions {
      display: flex;
      gap: 8px;
    }

    @media (max-width: 760px) {
      .wrap { width: min(1080px, 95vw); }
      .search-top {
        grid-template-columns: 1fr;
      }
      .filters-grid {
        grid-template-columns: 1fr;
      }
      .meta,
      .ops,
      .pager {
        flex-direction: column;
        align-items: flex-start;
      }
      .stats-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }
  </style>
</head>
<body>
  <main class="wrap">
    <section class="hero">
      <h1>MailVault</h1>
      <p id="heroSubtitle">Historical inbox for fast lookup of indexed messages.</p>
    </section>

    <section class="stats-panel">
      <h2 class="stats-title" id="statsTitle">Status</h2>
      <div class="stats-grid">
        <div class="stats-card"><div class="stats-label" id="labelTotalMessages">Messages</div><div id="statTotalMessages" class="stats-value">-</div></div>
        <div class="stats-card"><div class="stats-label" id="labelTotalWithHtml">With HTML</div><div id="statTotalWithHtml" class="stats-value">-</div></div>
        <div class="stats-card"><div class="stats-label" id="labelTotalAttachments">Attachments</div><div id="statTotalAttachments" class="stats-value">-</div></div>
        <div class="stats-card"><div class="stats-label" id="labelAssetsDownloaded">Downloaded assets</div><div id="statAssetsDownloaded" class="stats-value">-</div></div>
        <div class="stats-card"><div class="stats-label" id="labelAssetsFailed">Failed assets</div><div id="statAssetsFailed" class="stats-value">-</div></div>
        <div class="stats-card"><div class="stats-label" id="labelBytesAttachments">Attachment bytes</div><div id="statBytesAttachments" class="stats-value">-</div></div>
        <div class="stats-card"><div class="stats-label" id="labelBytesAssets">Asset bytes</div><div id="statBytesAssets" class="stats-value">-</div></div>
        <div class="stats-card"><div class="stats-label" id="labelLastIndex">Last index</div><div id="statLastIndexAt" class="stats-value">-</div></div>
      </div>
    </section>

    <section class="panel">
      <form id="searchForm" class="search">
        <div class="search-top">
          <input id="query" type="text" placeholder="Search by subject, sender or content terms" autocomplete="off" />
          <button id="searchBtn" type="submit" class="btn-primary">Search</button>
          <button id="clearBtn" type="button" class="btn-ghost">Clear all</button>
          <select id="languageSelect" class="language-select">
            <option value="en">English</option>
            <option value="pt-BR">Português (Brasil)</option>
          </select>
        </div>
        <div class="filters-grid">
          <div class="filter-field">
            <label id="yearFilterLabel" for="yearFilter">Year</label>
            <input id="yearFilter" type="number" min="1970" max="2100" placeholder="All" />
          </div>
          <div class="filter-field">
            <label id="hasAttachmentsFilterLabel" for="hasAttachmentsFilter">Attachments</label>
            <select id="hasAttachmentsFilter">
              <option value="">All</option>
              <option value="true">With attachments</option>
              <option value="false">Without attachments</option>
            </select>
          </div>
          <div class="filter-field">
            <label id="hasHtmlFilterLabel" for="hasHtmlFilter">HTML</label>
            <select id="hasHtmlFilter">
              <option value="">All</option>
              <option value="true">With HTML</option>
              <option value="false">Without HTML</option>
            </select>
          </div>
          <div class="filter-field">
            <label id="hasFrozenImagesFilterLabel" for="hasFrozenImagesFilter">Frozen images</label>
            <select id="hasFrozenImagesFilter">
              <option value="">All</option>
              <option value="true">With frozen images</option>
              <option value="false">Without frozen images</option>
            </select>
          </div>
        </div>
        <div class="filter-actions">
          <div id="activeFilters" class="chips"></div>
        </div>
      </form>

      <div class="ops">
        <div class="ops-actions">
          <button id="indexBtn" type="button" class="btn-primary">Index (incremental)</button>
          <button id="reindexBtn" type="button" class="btn-ghost">Reindex (full)</button>
          <button id="freezePendingBtn" type="button" class="btn-ghost">Freeze pending</button>
          <button id="maintenanceBtn" type="button" class="btn-ghost">Maintenance (cleanup/vacuum)</button>
          <button id="resetIndexedDataBtn" type="button" class="btn-ghost">Reset indexed data (destructive)</button>
        </div>
        <span id="indexStatus" class="ops-status"></span>
      </div>

      <div class="meta">
        <span id="summary">Loading messages...</span>
        <span id="searchHint">Tip: press <span class="kbd">/</span> to focus search</span>
      </div>

      <ul id="results" class="list"></ul>

      <div class="pager">
        <span id="pageInfo">Page 1</span>
        <div class="pager-actions">
          <button id="prevBtn" type="button" class="btn-ghost">Previous</button>
          <button id="nextBtn" type="button" class="btn-ghost">Next</button>
        </div>
      </div>
    </section>
  </main>

  <script>
    const PAGE_SIZE = 40;

    const searchForm = document.getElementById('searchForm');
    const queryInput = document.getElementById('query');
    const yearFilter = document.getElementById('yearFilter');
    const hasAttachmentsFilter = document.getElementById('hasAttachmentsFilter');
    const hasHtmlFilter = document.getElementById('hasHtmlFilter');
    const hasFrozenImagesFilter = document.getElementById('hasFrozenImagesFilter');
    const activeFilters = document.getElementById('activeFilters');
    const clearBtn = document.getElementById('clearBtn');
    const searchBtn = document.getElementById('searchBtn');
    const languageSelect = document.getElementById('languageSelect');
    const results = document.getElementById('results');
    const summary = document.getElementById('summary');
    const indexBtn = document.getElementById('indexBtn');
    const reindexBtn = document.getElementById('reindexBtn');
    const freezePendingBtn = document.getElementById('freezePendingBtn');
    const maintenanceBtn = document.getElementById('maintenanceBtn');
    const resetIndexedDataBtn = document.getElementById('resetIndexedDataBtn');
    const indexStatus = document.getElementById('indexStatus');
    const pageInfo = document.getElementById('pageInfo');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const statTotalMessages = document.getElementById('statTotalMessages');
    const statTotalWithHtml = document.getElementById('statTotalWithHtml');
    const statTotalAttachments = document.getElementById('statTotalAttachments');
    const statAssetsDownloaded = document.getElementById('statAssetsDownloaded');
    const statAssetsFailed = document.getElementById('statAssetsFailed');
    const statBytesAttachments = document.getElementById('statBytesAttachments');
    const statBytesAssets = document.getElementById('statBytesAssets');
    const statLastIndexAt = document.getElementById('statLastIndexAt');
    const heroSubtitle = document.getElementById('heroSubtitle');
    const statsTitle = document.getElementById('statsTitle');
    const searchHint = document.getElementById('searchHint');

    let state = {
      page: 0,
      total: 0,
      query: '',
      year: null,
      hasAttachments: null,
      hasHtml: null,
      hasFrozenImages: null,
      itemsCount: 0,
      items: [],
      loading: false,
      language: 'en',
    };

    const I18N = {
      en: {
        pageTitle: 'MailVault - Historical Inbox',
        heroSubtitle: 'Historical inbox for fast lookup of indexed messages.',
        statsTitle: 'Status',
        labelTotalMessages: 'Messages',
        labelTotalWithHtml: 'With HTML',
        labelTotalAttachments: 'Attachments',
        labelAssetsDownloaded: 'Downloaded assets',
        labelAssetsFailed: 'Failed assets',
        labelBytesAttachments: 'Attachment bytes',
        labelBytesAssets: 'Asset bytes',
        labelLastIndex: 'Last index',
        searchPlaceholder: 'Search by subject, sender or content terms',
        searchBtn: 'Search',
        clearBtn: 'Clear all',
        yearFilterLabel: 'Year',
        yearFilterPlaceholder: 'All',
        hasAttachmentsFilterLabel: 'Attachments',
        hasAttachmentsAny: 'All',
        hasAttachmentsTrue: 'With attachments',
        hasAttachmentsFalse: 'Without attachments',
        hasHtmlFilterLabel: 'HTML',
        hasHtmlAny: 'All',
        hasHtmlTrue: 'With HTML',
        hasHtmlFalse: 'Without HTML',
        hasFrozenImagesFilterLabel: 'Frozen images',
        hasFrozenImagesAny: 'All',
        hasFrozenImagesTrue: 'With frozen images',
        hasFrozenImagesFalse: 'Without frozen images',
        indexBtn: 'Index (incremental)',
        reindexBtn: 'Reindex (full)',
        freezePendingBtn: 'Freeze pending',
        maintenanceBtn: 'Maintenance (cleanup/vacuum)',
        resetIndexedDataBtn: 'Reset indexed data (destructive)',
        prevBtn: 'Previous',
        nextBtn: 'Next',
        searchHint: 'Tip: press <span class="kbd">/</span> to focus search',
        summaryLoading: 'Loading messages...',
        summaryNoResults: 'No results for current filters.',
        summaryNoMessages: 'No indexed messages yet.',
        summaryShowing: 'Showing {start}-{end} of {total} messages',
        pageInfo: 'Page {current} of {total}',
        listLoading: 'Refreshing results...',
        listEmpty: 'No messages found.',
        listError: 'Failed to load messages.',
        listNetworkError: 'Network failure while loading messages.',
        noDate: '(no date)',
        noSender: '(no sender)',
        noSubject: '(no subject)',
        noPreview: '(no preview)',
        badgeHtml: 'HTML',
        badgeAttachments: 'Attachments: {count}',
        badgeFrozen: 'Frozen',
        badgeFailure: 'Failed: {count}',
        badgeFreezeIgnored: 'Freeze ignored',
        freezeIgnoreAction: 'Ignore freeze',
        freezeUnignoreAction: 'Unignore freeze',
        freezeIgnoreDone: 'Message marked to ignore freeze.',
        freezeUnignoreDone: 'Message removed from freeze ignore.',
        freezeIgnoreFailed: 'Failed to update freeze ignore flag.',
        freezeIgnoreNetworkFailed: 'Network failure while updating freeze ignore flag.',
        chipSearch: 'Search: {value}',
        chipYear: 'Year: {value}',
        chipYes: 'yes',
        chipNo: 'no',
        chipAttachments: 'Attachments: {value}',
        chipHtml: 'HTML: {value}',
        chipFrozenImages: 'Frozen images: {value}',
        removeFilterAria: 'Remove filter',
        opInProgress: '{action} in progress...',
        opFailed: 'Failed to {action}.',
        opNetworkFailed: 'Network failure while trying to {action}.',
        opDone: '{action} finished: inserted={inserted}, updated={updated}, skipped={skipped}',
        actionIndexing: 'index',
        actionReindexing: 'reindex',
        actionMaintenance: 'run maintenance',
        maintenanceRunning: 'Maintenance in progress...',
        maintenanceCleanupFailed: 'Failed to run cleanup.',
        maintenanceVacuumFailed: 'Cleanup finished, but VACUUM failed.',
        maintenanceDone: 'Maintenance finished: removedFiles={removedFiles}, removedMessages={removedMessages}, vacuumMs={vacuumMs}',
        maintenanceNetworkFailed: 'Network failure while running maintenance.',
        resetIndexedDataConfirm1: 'This action is destructive and irreversible. It will delete indexed messages, message bodies, attachments, and assets, then run VACUUM. Continue?',
        resetIndexedDataPrompt: 'Type {token} to confirm destructive reset:',
        resetIndexedDataCancelled: 'Destructive reset canceled.',
        resetIndexedDataRunning: 'Resetting indexed data and compacting database...',
        resetIndexedDataDone: 'Reset finished: messages={messages}, bodies={bodies}, attachmentRows={attachmentsRows}, assetRows={assetsRows}, attachmentFiles={attachmentFiles}, assetFiles={assetFiles}, vacuumMs={vacuumMs}',
        resetIndexedDataFailed: 'Failed to reset indexed data.',
        resetIndexedDataNetworkFailed: 'Network failure while resetting indexed data.',
        resetIndexedDataToken: 'RESET',
        freezePendingNone: 'No pending freeze messages on this page.',
        freezePendingConfirm: 'Freeze remote images for {count} pending message(s) on current page?',
        freezePendingProgress: 'Freezing pending... {current}/{total}',
        freezePendingDone: 'Pending freeze finished: messages={messages}, downloaded={downloaded}, failed={failed}, skipped={skipped}, requestErrors={requestErrors}',
        freezePendingNetworkFailed: 'Network failure while freezing pending messages.',
        reindexConfirm: 'Full reindex will re-read all .eml files and update metadata/bodies. It may take time. Continue?',
        maintenanceConfirm: 'Maintenance removes orphan files and runs SQLite VACUUM. It may consume IO/time. Continue?',
      },
      'pt-BR': {
        pageTitle: 'MailVault - Caixa Historica',
        heroSubtitle: 'Caixa historica para consulta rapida de mensagens indexadas.',
        statsTitle: 'Status',
        labelTotalMessages: 'Mensagens',
        labelTotalWithHtml: 'Com HTML',
        labelTotalAttachments: 'Anexos',
        labelAssetsDownloaded: 'Assets baixados',
        labelAssetsFailed: 'Assets falhos',
        labelBytesAttachments: 'Bytes anexos',
        labelBytesAssets: 'Bytes assets',
        labelLastIndex: 'Ultimo index',
        searchPlaceholder: 'Buscar por assunto, remetente ou termos do conteudo',
        searchBtn: 'Buscar',
        clearBtn: 'Limpar tudo',
        yearFilterLabel: 'Ano',
        yearFilterPlaceholder: 'Todos',
        hasAttachmentsFilterLabel: 'Anexos',
        hasAttachmentsAny: 'Todos',
        hasAttachmentsTrue: 'Com anexos',
        hasAttachmentsFalse: 'Sem anexos',
        hasHtmlFilterLabel: 'HTML',
        hasHtmlAny: 'Todos',
        hasHtmlTrue: 'Com HTML',
        hasHtmlFalse: 'Sem HTML',
        hasFrozenImagesFilterLabel: 'Imagens congeladas',
        hasFrozenImagesAny: 'Todos',
        hasFrozenImagesTrue: 'Com imagens congeladas',
        hasFrozenImagesFalse: 'Sem imagens congeladas',
        indexBtn: 'Indexar (incremental)',
        reindexBtn: 'Reindexar (completo)',
        freezePendingBtn: 'Congelar pendentes',
        maintenanceBtn: 'Manutencao (limpeza/vacuum)',
        resetIndexedDataBtn: 'Zerar dados indexados (destrutivo)',
        prevBtn: 'Anterior',
        nextBtn: 'Proxima',
        searchHint: 'Dica: pressione <span class="kbd">/</span> para focar a busca',
        summaryLoading: 'Carregando mensagens...',
        summaryNoResults: 'Nenhum resultado para os filtros atuais.',
        summaryNoMessages: 'Nao ha mensagens indexadas ainda.',
        summaryShowing: 'Exibindo {start}-{end} de {total} mensagens',
        pageInfo: 'Pagina {current} de {total}',
        listLoading: 'Atualizando resultados...',
        listEmpty: 'Nenhuma mensagem encontrada.',
        listError: 'Erro ao carregar mensagens.',
        listNetworkError: 'Falha de rede ao carregar mensagens.',
        noDate: '(sem data)',
        noSender: '(sem remetente)',
        noSubject: '(sem assunto)',
        noPreview: '(sem preview)',
        badgeHtml: 'HTML',
        badgeAttachments: 'Anexos: {count}',
        badgeFrozen: 'Congelado',
        badgeFailure: 'Falha: {count}',
        badgeFreezeIgnored: 'Freeze ignorado',
        freezeIgnoreAction: 'Ignorar freeze',
        freezeUnignoreAction: 'Desfazer ignorar freeze',
        freezeIgnoreDone: 'Mensagem marcada para ignorar freeze.',
        freezeUnignoreDone: 'Mensagem removida da lista de ignorados.',
        freezeIgnoreFailed: 'Falha ao atualizar ignorar freeze.',
        freezeIgnoreNetworkFailed: 'Falha de rede ao atualizar ignorar freeze.',
        chipSearch: 'Busca: {value}',
        chipYear: 'Ano: {value}',
        chipYes: 'sim',
        chipNo: 'nao',
        chipAttachments: 'Anexos: {value}',
        chipHtml: 'HTML: {value}',
        chipFrozenImages: 'Imagens congeladas: {value}',
        removeFilterAria: 'Remover filtro',
        opInProgress: '{action} em andamento...',
        opFailed: 'Falha ao {action}.',
        opNetworkFailed: 'Falha de rede ao {action}.',
        opDone: '{action} concluida: inserted={inserted}, updated={updated}, skipped={skipped}',
        actionIndexing: 'indexar',
        actionReindexing: 'reindexar',
        actionMaintenance: 'executar manutencao',
        maintenanceRunning: 'Manutencao em andamento...',
        maintenanceCleanupFailed: 'Falha ao executar limpeza.',
        maintenanceVacuumFailed: 'Limpeza concluida, mas VACUUM falhou.',
        maintenanceDone: 'Manutencao concluida: arquivosRemovidos={removedFiles}, mensagensRemovidas={removedMessages}, vacuumMs={vacuumMs}',
        maintenanceNetworkFailed: 'Falha de rede ao executar manutencao.',
        resetIndexedDataConfirm1: 'Esta acao e destrutiva e irreversivel. Vai apagar mensagens indexadas, corpos, anexos e assets, e executar VACUUM. Deseja continuar?',
        resetIndexedDataPrompt: 'Digite {token} para confirmar o reset destrutivo:',
        resetIndexedDataCancelled: 'Reset destrutivo cancelado.',
        resetIndexedDataRunning: 'Zerando dados indexados e compactando banco...',
        resetIndexedDataDone: 'Reset concluido: mensagens={messages}, corpos={bodies}, linhasAnexos={attachmentsRows}, linhasAssets={assetsRows}, arquivosAnexos={attachmentFiles}, arquivosAssets={assetFiles}, vacuumMs={vacuumMs}',
        resetIndexedDataFailed: 'Falha ao zerar dados indexados.',
        resetIndexedDataNetworkFailed: 'Falha de rede ao zerar dados indexados.',
        resetIndexedDataToken: 'RESET',
        freezePendingNone: 'Nenhuma mensagem pendente de freeze nesta pagina.',
        freezePendingConfirm: 'Congelar imagens em {count} mensagem(ns) pendente(s) da pagina atual?',
        freezePendingProgress: 'Congelando pendentes... {current}/{total}',
        freezePendingDone: 'Freeze pendentes concluido: mensagens={messages}, baixadas={downloaded}, falhas={failed}, ignoradas={skipped}, errosReq={requestErrors}',
        freezePendingNetworkFailed: 'Falha de rede ao congelar mensagens pendentes.',
        reindexConfirm: 'Reindexacao completa vai reler todos os .eml e atualizar metadados/corpos. Pode demorar. Deseja continuar?',
        maintenanceConfirm: 'Manutencao remove arquivos orfaos e executa VACUUM no SQLite. Pode consumir IO e tempo. Deseja continuar?',
      },
    };

    function t(key, vars = {}) {
      const bundle = I18N[state.language] || I18N.en;
      const template = bundle[key] ?? I18N.en[key] ?? key;
      return template.replaceAll(/\{(\w+)}/g, (_, variable) => String(vars[variable] ?? ''));
    }

    function escapeHtml(value) {
      return (value ?? '')
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;');
    }

    function escapeRegExp(value) {
      return value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    function extractHighlightTerms(query) {
      if (!query) {
        return [];
      }
      const terms = query.match(/[A-Za-z0-9À-ÿ]{2,}/g) || [];
      return [...new Set(terms.map((term) => term.toLowerCase()))]
        .sort((a, b) => b.length - a.length)
        .slice(0, 8);
    }

    function highlightText(text, query) {
      const source = text || '';
      const terms = extractHighlightTerms(query);
      if (!terms.length || !source) {
        return escapeHtml(source);
      }
      const pattern = new RegExp(`(${terms.map(escapeRegExp).join('|')})`, 'gi');
      return source
        .split(pattern)
        .map((part, index) => (index % 2 === 1 ? `<mark>${escapeHtml(part)}</mark>` : escapeHtml(part)))
        .join('');
    }

    function formatDate(epochMs) {
      const numeric = Number(epochMs);
      if (!Number.isFinite(numeric) || numeric <= 0) {
        return t('noDate');
      }
      return new Intl.DateTimeFormat(state.language === 'pt-BR' ? 'pt-BR' : 'en-US', {
        day: '2-digit',
        month: 'short',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        hour12: false,
      }).format(new Date(numeric));
    }

    function applyStaticTexts() {
      document.documentElement.lang = state.language;
      document.title = t('pageTitle');
      heroSubtitle.textContent = t('heroSubtitle');
      statsTitle.textContent = t('statsTitle');
      document.getElementById('labelTotalMessages').textContent = t('labelTotalMessages');
      document.getElementById('labelTotalWithHtml').textContent = t('labelTotalWithHtml');
      document.getElementById('labelTotalAttachments').textContent = t('labelTotalAttachments');
      document.getElementById('labelAssetsDownloaded').textContent = t('labelAssetsDownloaded');
      document.getElementById('labelAssetsFailed').textContent = t('labelAssetsFailed');
      document.getElementById('labelBytesAttachments').textContent = t('labelBytesAttachments');
      document.getElementById('labelBytesAssets').textContent = t('labelBytesAssets');
      document.getElementById('labelLastIndex').textContent = t('labelLastIndex');
      queryInput.placeholder = t('searchPlaceholder');
      searchBtn.textContent = t('searchBtn');
      clearBtn.textContent = t('clearBtn');
      document.getElementById('yearFilterLabel').textContent = t('yearFilterLabel');
      yearFilter.placeholder = t('yearFilterPlaceholder');
      document.getElementById('hasAttachmentsFilterLabel').textContent = t('hasAttachmentsFilterLabel');
      hasAttachmentsFilter.options[0].textContent = t('hasAttachmentsAny');
      hasAttachmentsFilter.options[1].textContent = t('hasAttachmentsTrue');
      hasAttachmentsFilter.options[2].textContent = t('hasAttachmentsFalse');
      document.getElementById('hasHtmlFilterLabel').textContent = t('hasHtmlFilterLabel');
      hasHtmlFilter.options[0].textContent = t('hasHtmlAny');
      hasHtmlFilter.options[1].textContent = t('hasHtmlTrue');
      hasHtmlFilter.options[2].textContent = t('hasHtmlFalse');
      document.getElementById('hasFrozenImagesFilterLabel').textContent = t('hasFrozenImagesFilterLabel');
      hasFrozenImagesFilter.options[0].textContent = t('hasFrozenImagesAny');
      hasFrozenImagesFilter.options[1].textContent = t('hasFrozenImagesTrue');
      hasFrozenImagesFilter.options[2].textContent = t('hasFrozenImagesFalse');
      indexBtn.textContent = t('indexBtn');
      reindexBtn.textContent = t('reindexBtn');
      freezePendingBtn.textContent = t('freezePendingBtn');
      maintenanceBtn.textContent = t('maintenanceBtn');
      resetIndexedDataBtn.textContent = t('resetIndexedDataBtn');
      searchHint.innerHTML = t('searchHint');
      prevBtn.textContent = t('prevBtn') || 'Previous';
      nextBtn.textContent = t('nextBtn') || 'Next';
      languageSelect.value = state.language;
    }

    function apiFetch(input, init = {}) {
      return fetch(input, { credentials: 'same-origin', ...init });
    }

    async function loadLanguagePreference() {
      try {
        const response = await apiFetch('/api/ui/language');
        if (!response.ok) {
          state.language = 'en';
          return;
        }
        const data = await response.json();
        state.language = data.language === 'pt-BR' ? 'pt-BR' : 'en';
      } catch (_) {
        state.language = 'en';
      }
    }

    async function saveLanguagePreference(language) {
      const normalized = language === 'pt-BR' ? 'pt-BR' : 'en';
      state.language = normalized;
      applyStaticTexts();
      renderActiveFilters();
      renderMeta();
      renderItems(state.items, null);
      try {
        await apiFetch('/api/ui/language', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ language: normalized }),
        });
      } catch (_) {
        // Ignore save failure, keep local selection.
      }
    }

    function currentQueryFromUrl() {
      const params = new URLSearchParams(window.location.search);
      return (params.get('query') || '').trim();
    }

    function currentYearFromUrl() {
      const params = new URLSearchParams(window.location.search);
      const value = params.get('year');
      if (!value) {
        return null;
      }
      const parsed = Number(value);
      if (!Number.isFinite(parsed) || parsed < 0) {
        return null;
      }
      return Math.floor(parsed);
    }

    function parseBooleanParam(value) {
      if (value === 'true') {
        return true;
      }
      if (value === 'false') {
        return false;
      }
      return null;
    }

    function currentBooleanFilterFromUrl(key) {
      const params = new URLSearchParams(window.location.search);
      return parseBooleanParam(params.get(key));
    }

    function currentPageFromUrl() {
      const params = new URLSearchParams(window.location.search);
      const page = Number(params.get('page') || '0');
      if (!Number.isFinite(page) || page < 0) {
        return 0;
      }
      return Math.floor(page);
    }

    function syncUrl() {
      const params = new URLSearchParams();
      if (state.query) {
        params.set('query', state.query);
      }
      if (state.year !== null) {
        params.set('year', String(state.year));
      }
      if (state.hasAttachments !== null) {
        params.set('hasAttachments', String(state.hasAttachments));
      }
      if (state.hasHtml !== null) {
        params.set('hasHtml', String(state.hasHtml));
      }
      if (state.hasFrozenImages !== null) {
        params.set('hasFrozenImages', String(state.hasFrozenImages));
      }
      if (state.page > 0) {
        params.set('page', String(state.page));
      }
      const queryString = params.toString();
      const newUrl = queryString ? `/?${queryString}` : '/';
      window.history.replaceState(null, '', newUrl);
      window.sessionStorage.setItem('mailvault:lastListQuery', queryString ? `?${queryString}` : '');
    }

    function renderMeta() {
      const start = state.total === 0 ? 0 : (state.page * PAGE_SIZE) + 1;
      const end = state.page * PAGE_SIZE + state.itemsCount;
      if (state.loading) {
        summary.textContent = t('summaryLoading');
      } else if (state.total === 0) {
        summary.textContent = hasActiveFilters() ? t('summaryNoResults') : t('summaryNoMessages');
      } else {
        summary.textContent = t('summaryShowing', { start, end, total: state.total });
      }

      const totalPages = Math.max(1, Math.ceil(state.total / PAGE_SIZE));
      pageInfo.textContent = t('pageInfo', { current: Math.min(state.page + 1, totalPages), total: totalPages });
      prevBtn.disabled = state.loading || state.page <= 0;
      nextBtn.disabled = state.loading || (state.page + 1) * PAGE_SIZE >= state.total;
    }

    function renderItems(items, errorMessage) {
      if (errorMessage) {
        results.innerHTML = `<li class="error">${escapeHtml(errorMessage)}</li>`;
        return;
      }

      if (state.loading) {
        results.innerHTML = `<li class="loading">${escapeHtml(t('listLoading'))}</li>`;
        return;
      }

      if (!items.length) {
        results.innerHTML = `<li class="empty">${escapeHtml(t('listEmpty'))}</li>`;
        return;
      }

      results.innerHTML = items.map((item) => {
        const date = formatDate(item.dateEpoch ?? item.fileMtimeEpoch);
        const from = item.fromDisplay || item.fromRaw || t('noSender');
        const subject = item.subjectDisplay || item.subject || t('noSubject');
        const snippet = item.snippet || t('noPreview');
        const highlightedSubject = highlightText(subject, state.query);
        const highlightedSnippet = highlightText(snippet, state.query);
        const badges = [];
        const attachmentsCount = Number(item.attachmentsCount || 0);
        const frozenAssetsCount = Number(item.frozenAssetsCount || 0);
        const assetsFailedCount = Number(item.assetsFailedCount || 0);
        const freezeIgnored = Boolean(item.freezeIgnored);
        if (item.hasHtml) {
          badges.push(`<span class="mini-badge">${escapeHtml(t('badgeHtml'))}</span>`);
        }
        if (attachmentsCount > 0) {
          badges.push(`<span class="mini-badge">${escapeHtml(t('badgeAttachments', { count: attachmentsCount }))}</span>`);
        }
        if (frozenAssetsCount > 0) {
          badges.push(`<span class="mini-badge warn">${escapeHtml(t('badgeFrozen'))}</span>`);
        }
        if (assetsFailedCount > 0) {
          badges.push(`<span class="mini-badge danger">${escapeHtml(t('badgeFailure', { count: assetsFailedCount }))}</span>`);
        }
        if (freezeIgnored) {
          badges.push(`<span class="mini-badge muted">${escapeHtml(t('badgeFreezeIgnored'))}</span>`);
        }
        const detailParams = new URLSearchParams();
        if (window.location.search) {
          detailParams.set('return', window.location.search);
        }
        const detailSuffix = detailParams.toString();
        return `
          <li class="item">
            <div class="item-meta">
              <span>${escapeHtml(date)}</span>
              <span class="dot">${escapeHtml(from)}</span>
            </div>
            <div class="item-head">
              <a class="item-subject" href="/messages/${encodeURIComponent(item.id)}${detailSuffix ? `?${detailSuffix}` : ''}">${highlightedSubject}</a>
              <span class="item-badges">${badges.join('')}</span>
              ${item.hasHtml ? `<button type="button" class="inline-action" data-action="toggle-freeze-ignored" data-id="${escapeHtml(item.id)}" data-next-ignored="${freezeIgnored ? 'false' : 'true'}">${escapeHtml(freezeIgnored ? t('freezeUnignoreAction') : t('freezeIgnoreAction'))}</button>` : ''}
            </div>
            <div class="item-snippet">${highlightedSnippet}</div>
          </li>`;
      }).join('');
    }

    async function loadMessages() {
      state.loading = true;
      renderMeta();
      renderItems([], null);

      const params = new URLSearchParams({
        page: String(state.page),
        size: String(PAGE_SIZE),
      });
      if (state.query) {
        params.set('query', state.query);
      }
      if (state.year !== null) {
        params.set('year', String(state.year));
      }
      if (state.hasAttachments !== null) {
        params.set('hasAttachments', String(state.hasAttachments));
      }
      if (state.hasHtml !== null) {
        params.set('hasHtml', String(state.hasHtml));
      }
      if (state.hasFrozenImages !== null) {
        params.set('hasFrozenImages', String(state.hasFrozenImages));
      }

      try {
        const response = await apiFetch(`/api/messages?${params.toString()}`);
        if (!response.ok) {
          state.loading = false;
          state.items = [];
          state.total = 0;
          state.itemsCount = 0;
          renderMeta();
          renderItems([], t('listError'));
          return;
        }

        const data = await response.json();
        const items = data.items || [];
        state.items = items;
        state.total = Number(data.total || 0);
        state.itemsCount = items.length;
        state.loading = false;
        renderMeta();
        renderItems(items, null);
      } catch (_) {
        state.loading = false;
        state.items = [];
        state.total = 0;
        state.itemsCount = 0;
        renderMeta();
        renderItems([], t('listNetworkError'));
      }
    }

    function applyAndLoad(next) {
      state = { ...state, ...next };
      renderActiveFilters();
      syncUrl();
      loadMessages();
    }

    function hasActiveFilters() {
      return Boolean(
        state.query ||
        state.year !== null ||
        state.hasAttachments !== null ||
        state.hasHtml !== null ||
        state.hasFrozenImages !== null,
      );
    }

    function renderActiveFilters() {
      const chips = [];
      if (state.query) {
        chips.push({ key: 'query', label: t('chipSearch', { value: state.query }) });
      }
      if (state.year !== null) {
        chips.push({ key: 'year', label: t('chipYear', { value: state.year }) });
      }
      if (state.hasAttachments !== null) {
        chips.push({ key: 'hasAttachments', label: t('chipAttachments', { value: state.hasAttachments ? t('chipYes') : t('chipNo') }) });
      }
      if (state.hasHtml !== null) {
        chips.push({ key: 'hasHtml', label: t('chipHtml', { value: state.hasHtml ? t('chipYes') : t('chipNo') }) });
      }
      if (state.hasFrozenImages !== null) {
        chips.push({ key: 'hasFrozenImages', label: t('chipFrozenImages', { value: state.hasFrozenImages ? t('chipYes') : t('chipNo') }) });
      }

      if (!chips.length) {
        activeFilters.innerHTML = '';
        return;
      }

      activeFilters.innerHTML = chips.map((chip) => `
        <span class="chip">
          ${escapeHtml(chip.label)}
          <button type="button" data-filter-key="${chip.key}" aria-label="${escapeHtml(t('removeFilterAria'))}">x</button>
        </span>
      `).join('');
    }

    function clearFilterByKey(key) {
      const patch = { page: 0 };
      if (key === 'query') {
        patch.query = '';
      }
      if (key === 'year') {
        patch.year = null;
      }
      if (key === 'hasAttachments') {
        patch.hasAttachments = null;
      }
      if (key === 'hasHtml') {
        patch.hasHtml = null;
      }
      if (key === 'hasFrozenImages') {
        patch.hasFrozenImages = null;
      }
      syncFormFromState({ ...state, ...patch });
      applyAndLoad(patch);
    }

    function syncFormFromState(nextState = state) {
      queryInput.value = nextState.query || '';
      yearFilter.value = nextState.year === null ? '' : String(nextState.year);
      hasAttachmentsFilter.value = nextState.hasAttachments === null ? '' : String(nextState.hasAttachments);
      hasHtmlFilter.value = nextState.hasHtml === null ? '' : String(nextState.hasHtml);
      hasFrozenImagesFilter.value = nextState.hasFrozenImages === null ? '' : String(nextState.hasFrozenImages);
    }

    function formatNumber(value) {
      return Number(value || 0).toLocaleString(state.language === 'pt-BR' ? 'pt-BR' : 'en-US');
    }

    function setStatsFallback() {
      statTotalMessages.textContent = '-';
      statTotalWithHtml.textContent = '-';
      statTotalAttachments.textContent = '-';
      statAssetsDownloaded.textContent = '-';
      statAssetsFailed.textContent = '-';
      statBytesAttachments.textContent = '-';
      statBytesAssets.textContent = '-';
      statLastIndexAt.textContent = '-';
    }

    async function loadStats() {
      try {
        const response = await apiFetch('/api/stats');
        if (!response.ok) {
          setStatsFallback();
          return;
        }
        const stats = await response.json();
        statTotalMessages.textContent = formatNumber(stats.totalMessages);
        statTotalWithHtml.textContent = formatNumber(stats.totalWithHtml);
        statTotalAttachments.textContent = formatNumber(stats.totalAttachments);
        statAssetsDownloaded.textContent = formatNumber(stats.totalAssetsDownloaded);
        statAssetsFailed.textContent = formatNumber(stats.totalAssetsFailed);
        statBytesAttachments.textContent = formatNumber(stats.storageBytesAttachments);
        statBytesAssets.textContent = formatNumber(stats.storageBytesAssets);
        statLastIndexAt.textContent = stats.lastIndexAt || '-';
      } catch (_) {
        setStatsFallback();
      }
    }

    function setIndexRunning(running) {
      indexBtn.disabled = running;
      reindexBtn.disabled = running;
      freezePendingBtn.disabled = running;
      maintenanceBtn.disabled = running;
      resetIndexedDataBtn.disabled = running;
    }

    function setOpsStatus(kind, message) {
      indexStatus.className = `ops-status ${kind}`;
      indexStatus.textContent = message;
    }

    async function runIndex(actionLabel) {
      setIndexRunning(true);
      setOpsStatus('info', t('opInProgress', { action: actionLabel }));
      try {
        const response = await apiFetch('/api/index', { method: 'POST' });
        if (!response.ok) {
          setOpsStatus('error', t('opFailed', { action: actionLabel }));
          return;
        }
        const data = await response.json();
        setOpsStatus('ok', t('opDone', {
          action: actionLabel,
          inserted: data.inserted,
          updated: data.updated,
          skipped: data.skipped,
        }));
        applyAndLoad({ page: 0 });
        loadStats();
      } catch (_) {
        setOpsStatus('error', t('opNetworkFailed', { action: actionLabel }));
      } finally {
        setIndexRunning(false);
      }
    }

    async function runMaintenance() {
      setIndexRunning(true);
      setOpsStatus('info', t('maintenanceRunning'));
      try {
        const cleanupRes = await apiFetch('/api/maintenance/cleanup', { method: 'POST' });
        if (!cleanupRes.ok) {
          setOpsStatus('error', t('maintenanceCleanupFailed'));
          return;
        }
        const cleanup = await cleanupRes.json();

        const vacuumRes = await apiFetch('/api/maintenance/vacuum', { method: 'POST' });
        if (!vacuumRes.ok) {
          setOpsStatus('error', t('maintenanceVacuumFailed'));
          return;
        }
        const vacuum = await vacuumRes.json();
        setOpsStatus(
          'ok',
          t('maintenanceDone', {
            removedFiles: cleanup.removedAttachmentFiles + cleanup.removedAssetFiles,
            removedMessages: cleanup.removedMissingMessageRows,
            vacuumMs: vacuum.durationMs,
          }),
        );
        applyAndLoad({ page: 0 });
        loadStats();
      } catch (_) {
        setOpsStatus('error', t('maintenanceNetworkFailed'));
      } finally {
        setIndexRunning(false);
      }
    }

    async function runResetIndexedData() {
      const confirmed = window.confirm(t('resetIndexedDataConfirm1'));
      if (!confirmed) {
        setOpsStatus('info', t('resetIndexedDataCancelled'));
        return;
      }
      const token = t('resetIndexedDataToken');
      const typed = window.prompt(t('resetIndexedDataPrompt', { token }), '');
      if ((typed || '').trim() !== token) {
        setOpsStatus('info', t('resetIndexedDataCancelled'));
        return;
      }

      setIndexRunning(true);
      setOpsStatus('info', t('resetIndexedDataRunning'));
      try {
        const response = await apiFetch('/api/maintenance/reset-indexed-data', { method: 'POST' });
        if (!response.ok) {
          setOpsStatus('error', t('resetIndexedDataFailed'));
          return;
        }
        const data = await response.json();
        setOpsStatus(
          'ok',
          t('resetIndexedDataDone', {
            messages: data.removedMessages,
            bodies: data.removedMessageBodies,
            attachmentsRows: data.removedAttachmentsRows,
            assetsRows: data.removedAssetsRows,
            attachmentFiles: data.removedAttachmentFiles,
            assetFiles: data.removedAssetFiles,
            vacuumMs: data.vacuumDurationMs,
          }),
        );
        applyAndLoad({ page: 0 });
        loadStats();
      } catch (_) {
        setOpsStatus('error', t('resetIndexedDataNetworkFailed'));
      } finally {
        setIndexRunning(false);
      }
    }

    async function runFreezePending() {
      const confirmed = window.confirm(
        t('freezePendingConfirm', { count: state.itemsCount || PAGE_SIZE }),
      );
      if (!confirmed) {
        return;
      }

      setIndexRunning(true);
      try {
        const params = new URLSearchParams({
          page: String(state.page),
          size: String(PAGE_SIZE),
        });
        if (state.query) {
          params.set('query', state.query);
        }
        if (state.year !== null) {
          params.set('year', String(state.year));
        }
        if (state.hasAttachments !== null) {
          params.set('hasAttachments', String(state.hasAttachments));
        }
        if (state.hasHtml !== null) {
          params.set('hasHtml', String(state.hasHtml));
        }
        if (state.hasFrozenImages !== null) {
          params.set('hasFrozenImages', String(state.hasFrozenImages));
        }

        setOpsStatus('info', t('freezePendingProgress', { current: 1, total: 1 }));
        const response = await apiFetch(`/api/messages/freeze-pending?${params.toString()}`, { method: 'POST' });
        if (!response.ok) {
          setOpsStatus('error', t('freezePendingNetworkFailed'));
          return;
        }
        const data = await response.json();
        const candidates = Number(data.candidates || 0);
        if (candidates <= 0) {
          setOpsStatus('info', t('freezePendingNone'));
        } else {
          setOpsStatus(
            Number(data.requestErrors || 0) > 0 ? 'error' : 'ok',
            t('freezePendingDone', {
              messages: Number(data.messages || 0),
              downloaded: Number(data.downloaded || 0),
              failed: Number(data.failed || 0),
              skipped: Number(data.skipped || 0),
              requestErrors: Number(data.requestErrors || 0),
            }),
          );
        }
        await loadMessages();
        await loadStats();
      } finally {
        setIndexRunning(false);
      }
    }

    searchForm.addEventListener('submit', (event) => {
      event.preventDefault();
      const parsedYearRaw = yearFilter.value.trim();
      const parsedYear = parsedYearRaw ? Number(parsedYearRaw) : null;
      applyAndLoad({
        query: queryInput.value.trim(),
        year: Number.isFinite(parsedYear) && parsedYear >= 0 ? Math.floor(parsedYear) : null,
        hasAttachments: parseBooleanParam(hasAttachmentsFilter.value),
        hasHtml: parseBooleanParam(hasHtmlFilter.value),
        hasFrozenImages: parseBooleanParam(hasFrozenImagesFilter.value),
        page: 0,
      });
    });

    clearBtn.addEventListener('click', () => {
      syncFormFromState({
        ...state,
        query: '',
        year: null,
        hasAttachments: null,
        hasHtml: null,
        hasFrozenImages: null,
      });
      applyAndLoad({
        query: '',
        year: null,
        hasAttachments: null,
        hasHtml: null,
        hasFrozenImages: null,
        page: 0,
      });
      queryInput.focus();
    });

    activeFilters.addEventListener('click', (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) {
        return;
      }
      const key = target.getAttribute('data-filter-key');
      if (!key) {
        return;
      }
      clearFilterByKey(key);
    });

    indexBtn.addEventListener('click', () => {
      runIndex(t('actionIndexing'));
    });

    reindexBtn.addEventListener('click', () => {
      const confirmed = window.confirm(
        t('reindexConfirm'),
      );
      if (!confirmed) {
        return;
      }
      runIndex(t('actionReindexing'));
    });

    maintenanceBtn.addEventListener('click', () => {
      const confirmed = window.confirm(
        t('maintenanceConfirm'),
      );
      if (!confirmed) {
        return;
      }
      runMaintenance();
    });

    resetIndexedDataBtn.addEventListener('click', () => {
      runResetIndexedData();
    });

    freezePendingBtn.addEventListener('click', () => {
      runFreezePending();
    });

    results.addEventListener('click', async (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) {
        return;
      }
      const button = target.closest('[data-action="toggle-freeze-ignored"]');
      if (!(button instanceof HTMLElement)) {
        return;
      }
      event.preventDefault();
      const id = button.getAttribute('data-id');
      const nextIgnored = button.getAttribute('data-next-ignored') === 'true';
      if (!id) {
        return;
      }

      button.setAttribute('disabled', 'disabled');
      try {
        const response = await apiFetch(`/api/messages/${encodeURIComponent(id)}/freeze-ignored?ignored=${nextIgnored}`, { method: 'PUT' });
        if (!response.ok) {
          setOpsStatus('error', t('freezeIgnoreFailed'));
          return;
        }
        const data = await response.json();
        state.items = (state.items || []).map((item) =>
          item.id === id ? { ...item, freezeIgnored: Boolean(data.freezeIgnored) } : item);
        renderItems(state.items, null);
        setOpsStatus('ok', data.freezeIgnored ? t('freezeIgnoreDone') : t('freezeUnignoreDone'));
      } catch (_) {
        setOpsStatus('error', t('freezeIgnoreNetworkFailed'));
      } finally {
        button.removeAttribute('disabled');
      }
    });

    prevBtn.addEventListener('click', () => {
      if (state.page > 0) {
        applyAndLoad({ page: state.page - 1 });
      }
    });

    nextBtn.addEventListener('click', () => {
      if ((state.page + 1) * PAGE_SIZE < state.total) {
        applyAndLoad({ page: state.page + 1 });
      }
    });

    languageSelect.addEventListener('change', () => {
      saveLanguagePreference(languageSelect.value);
    });

    document.addEventListener('keydown', (event) => {
      if (event.key === '/' && document.activeElement !== queryInput) {
        event.preventDefault();
        queryInput.focus();
      }
    });

    window.addEventListener('popstate', () => {
      state.query = currentQueryFromUrl();
      state.year = currentYearFromUrl();
      state.hasAttachments = currentBooleanFilterFromUrl('hasAttachments');
      state.hasHtml = currentBooleanFilterFromUrl('hasHtml');
      state.hasFrozenImages = currentBooleanFilterFromUrl('hasFrozenImages');
      state.page = currentPageFromUrl();
      syncFormFromState();
      renderActiveFilters();
      loadMessages();
    });

    async function initPage() {
      await loadLanguagePreference();
      applyStaticTexts();
      state.query = currentQueryFromUrl();
      state.year = currentYearFromUrl();
      state.hasAttachments = currentBooleanFilterFromUrl('hasAttachments');
      state.hasHtml = currentBooleanFilterFromUrl('hasHtml');
      state.hasFrozenImages = currentBooleanFilterFromUrl('hasFrozenImages');
      state.page = currentPageFromUrl();
      syncFormFromState();
      renderActiveFilters();
      await loadMessages();
      await loadStats();
    }

    initPage();
  </script>
</body>
</html>
